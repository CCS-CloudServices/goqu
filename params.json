{"name":"Goqu","tagline":"SQL builder and query library for golang","body":"```\r\n  __ _  ___   __ _ _   _\r\n / _` |/ _ \\ / _` | | | |\r\n| (_| | (_) | (_| | |_| |\r\n \\__, |\\___/ \\__, |\\__,_|\r\n |___/          |_|\r\n```\r\n[![GitHub tag](https://img.shields.io/github/tag/doug-martin/goqu.svg?style=flat)](https://github.com/doug-martin/goqu/releases)\r\n[![Build Status](https://travis-ci.org/doug-martin/goqu.svg?branch=master)](https://travis-ci.org/doug-martin/goqu)\r\n[![GoDoc](https://godoc.org/github.com/doug-martin/goqu?status.png)](http://godoc.org/github.com/doug-martin/goqu)\r\n[![GoCover](http://gocover.io/_badge/github.com/doug-martin/goqu)](http://gocover.io/github.com/doug-martin/goqu)\r\n[![Join the chat at https://gitter.im/doug-martin/goqu](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/doug-martin/goqu?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\n`goqu` is an expressive SQL builder\r\n\r\n* [Basics](#basics)\r\n* [Expressions](#expressions)\r\n    * [Complex Example](#complex-example)\r\n* [Querying](#querying)\r\n    * [Dataset](#dataset)\r\n        * [Prepared Statments](#dataset_prepared)\r\n    * [Database](#database)\r\n    * [Transactions](#transactions)\r\n* [Logging](#logging)\r\n* [Adapters](#adapters)\r\n* [Contributions](#contributions)\r\n* [Changelog](https://github.com/doug-martin/goqu/tree/master/HISTORY.md)\r\n\r\n\r\nThis library was built with the following goals:\r\n\r\n* Make the generation of SQL easy and enjoyable\r\n* Provide a DSL that accounts for the common SQL expressions, NOT every nuance for each database.\r\n* Allow users to use SQL when desired\r\n* Provide a simple query API for scanning rows\r\n* Allow the user to use the native sql.Db methods when desired\r\n\r\n## Features\r\n\r\n`goqu` comes with many features but here are a few of the more notable ones\r\n\r\n* Query Builder\r\n* Parameter interpolation (e.g `SELECT * FROM \"items\" WHERE \"id\" = ?` -> `SELECT * FROM \"items\" WHERE \"id\" = 1`)\r\n* Built from the ground up with adapters in mind\r\n* Insert, Multi Insert, Update, and Delete support\r\n* Scanning of rows to struct[s] or primitive value[s]\r\n\r\nWhile goqu may support the scanning of rows into structs it is not intended to be used as an ORM if you are looking for common ORM features like associations,\r\nor hooks I would recommend looking at some of the great ORM libraries such as:\r\n\r\n* [gorm](https://github.com/jinzhu/gorm)\r\n* [hood](https://github.com/eaigner/hood)\r\n\r\n<a name=\"basics\"></a>\r\n## Basics\r\n\r\nIn order to start using goqu with your database you need to load an adapter. We have included some adapters by default.\r\n\r\n1. Postgres - `import \"github.com/doug-martin/goqu/adapters/postgres\"`\r\n2. MySQL - `import \"github.com/doug-martin/goqu/adapters/mysql\"`\r\n3. SQLite3 - `import \"github.com/doug-martin/goqu/adapters/sqlite3\"`\r\n\r\nAdapters in goqu work the same way as a driver with the database in that they register themselves with goqu once loaded.\r\n\r\n```go\r\nimport (\r\n  \"database/sql\"\r\n  \"github.com/doug-martin/goqu\"\r\n  _ \"github.com/doug-martin/goqu/adapters/postgres\"\r\n  _ \"github.com/lib/pq\"\r\n)\r\n```\r\nNotice that we imported the adapter and driver for side effect only.\r\n\r\nOnce you have your adapter and driver loaded you can create a goqu.Database instance\r\n\r\n```go\r\npgDb, err := sql.Open(\"postgres\", \"user=postgres dbname=goqupostgres sslmode=disable \")\r\nif err != nil {\r\n    panic(err.Error())\r\n}\r\ndb := goqu.New(\"postgres\", pgDb)\r\n```\r\nNow that you have your goqu.Database you can build your SQL and it will be formatted appropriately for the provided dialect.\r\n\r\n```go\r\n//interpolated sql\r\nsql, _ := db.From(\"user\").Where(goqu.Ex{\r\n    \"id\": 10,\r\n}).ToSql()\r\nfmt.Println(sql)\r\n\r\n//prepared sql\r\nsql, args, _ := db.From(\"user\").\r\n    Prepared(true).\r\n    Where(goqu.Ex{\r\n        \"id\": 10,\r\n    }).\r\n    ToSql()\r\nfmt.Println(sql)\r\n```\r\nOutput\r\n```sql\r\nSELECT * FROM \"user\" WHERE \"id\" = 10\r\nSELECT * FROM \"user\" WHERE \"id\" = $1\r\n```\r\n\r\n<a name=\"expressions\"></a>\r\n### Expressions\r\n\r\n`goqu` provides an idiomatic DSL for generating SQL however the Dataset only provides the the different clause methods (e.g. Where, From, Select), most of these clause methods accept Expressions(with a few exceptions) which are the building blocks for your SQL statement, you can think of them as fragments of SQL.\r\n\r\nThe entry points for expressions are:\r\n\r\n* [`Ex{}`](https://godoc.org/github.com/doug-martin/goqu#Ex) - A map where the key will become an Identifier and the Key is the value, this is most commonly used in the Where clause. By default `Ex` will use the equality operator except in cases where the equality operator will not work, see the example below.\r\n```go\r\nsql, _, _ := db.From(\"items\").Where(goqu.Ex{\r\n\t\"col1\": \"a\",\r\n\t\"col2\": 1,\r\n\t\"col3\": true,\r\n\t\"col4\": false,\r\n\t\"col5\": nil,\r\n\t\"col6\": []string{\"a\", \"b\", \"c\"},\r\n}).ToSql()\r\nfmt.Println(sql)\r\n```\r\nOutput:\r\n```sql\r\nSELECT * FROM \"items\" WHERE ((\"col1\" = 'a') AND (\"col2\" = 1) AND (\"col3\" IS TRUE) AND (\"col4\" IS FALSE) AND (\"col5\" IS NULL) AND (\"col6\" IN ('a', 'b', 'c')))\r\n```\r\nYou can also use the [`Op`](https://godoc.org/github.com/doug-martin/goqu#Op) map which allows you to create more complex expressions using the map syntax. When using the `Op` map the key is the name of the comparison you want to make (e.g. `\"neq\"`, `\"like\"`, `\"is\"`, `\"in\"`), the key is case insensitive.\r\n```go\r\nsql, _, _ := db.From(\"items\").Where(goqu.Ex{\r\n    \"col1\": goqu.Op{\"neq\": \"a\"},\r\n    \"col3\": goqu.Op{\"isNot\": true},\r\n    \"col6\": goqu.Op{\"notIn\": []string{\"a\", \"b\", \"c\"}},\r\n}).ToSql()\r\nfmt.Println(sql)\r\n```\r\nOutput:\r\n```sql\r\nSELECT * FROM \"items\" WHERE ((\"col1\" != 'a') AND (\"col3\" IS NOT TRUE) AND (\"col6\" NOT IN ('a', 'b', 'c')))\r\n```\r\nFor a more complete examples see the [`Op`](https://godoc.org/github.com/doug-martin/goqu#Op) and [`Ex`](https://godoc.org/github.com/doug-martin/goqu#Ex) docs\r\n\r\n* [`ExOr{}`](https://godoc.org/github.com/doug-martin/goqu#ExOr) - A map where the key will become an Identifier and the Key is the value, this is most commonly used in the Where clause. By default `ExOr` will use the equality operator except in cases where the equality operator will not work, see the example below.\r\n```go\r\nsql, _, _ := db.From(\"items\").Where(goqu.ExOr{\r\n\t\"col1\": \"a\",\r\n\t\"col2\": 1,\r\n\t\"col3\": true,\r\n\t\"col4\": false,\r\n\t\"col5\": nil,\r\n\t\"col6\": []string{\"a\", \"b\", \"c\"},\r\n}).ToSql()\r\nfmt.Println(sql)\r\n```\r\nOutput:\r\n```sql\r\nSELECT * FROM \"items\" WHERE ((\"col1\" = 'a') OR (\"col2\" = 1) OR (\"col3\" IS TRUE) OR (\"col4\" IS FALSE) OR (\"col5\" IS NULL) OR (\"col6\" IN ('a', 'b', 'c')))\r\n```\r\nYou can also use the [`Op`](https://godoc.org/github.com/doug-martin/goqu#Op) map which allows you to create more complex expressions using the map syntax. When using the `Op` map the key is the name of the comparison you want to make (e.g. `\"neq\"`, `\"like\"`, `\"is\"`, `\"in\"`), the key is case insensitive.\r\n```go\r\nsql, _, _ := db.From(\"items\").Where(goqu.ExOr{\r\n    \"col1\": goqu.Op{\"neq\": \"a\"},\r\n    \"col3\": goqu.Op{\"isNot\": true},\r\n    \"col6\": goqu.Op{\"notIn\": []string{\"a\", \"b\", \"c\"}},\r\n}).ToSql()\r\nfmt.Println(sql)\r\n```\r\nOutput:\r\n```sql\r\nSELECT * FROM \"items\" WHERE ((\"col1\" != 'a') OR (\"col3\" IS NOT TRUE) OR (\"col6\" NOT IN ('a', 'b', 'c')))\r\n```\r\nFor a more complete examples see the [`Op`](https://godoc.org/github.com/doug-martin/goqu#Op) and [`ExOr`](https://godoc.org/github.com/doug-martin/goqu#Ex) docs\r\n\r\n* [`I()`](https://godoc.org/github.com/doug-martin/goqu#I) - An Identifier represents a schema, table, or column or any combination. You can use this when your expression cannot be expressed via the [`Ex`](https://godoc.org/github.com/doug-martin/goqu#Ex) map (e.g. Cast).\r\n```go\r\ngoqu.I(\"my_schema.table.col\")\r\ngoqu.I(\"table.col\")\r\ngoqu.I(\"col\")\r\n```\r\nIf you look at the [`IdentiferExpression`](https://godoc.org/github.com/doug-martin/goqu#IdentifierExpression) docs it implements many of your common sql operations that you would perform.\r\n```go\r\ngoqu.I(\"col\").Eq(10)\r\ngoqu.I(\"col\").In([]int64{1,2,3,4})\r\ngoqu.I(\"col\").Like(regexp.MustCompile(\"^(a|b)\")\r\ngoqu.I(\"col\").IsNull()\r\n```\r\nPlease see the exmaples for [`I()`](https://godoc.org/github.com/doug-martin/goqu#example-I) to see more in depth examples\r\n\r\n* [`L()`](https://godoc.org/github.com/doug-martin/goqu#example-L) - An SQL literal. You may find yourself in a situation where an IdentifierExpression cannot expression an SQL fragment that your database supports. In that case you can use a LiteralExpression\r\n```go\r\ngoqu.L(`\"col\"::TEXT = \"\"other_col\"::text`)\r\n```\r\nYou can also use placeholders in your literal. When using the LiteralExpressions placeholders are normalized to the ? character and will be transformed to the correct placeholder for your adapter (e.g. `?` mysql, `$1` postgres, `?` sqlite3)\r\n```go\r\ngoqu.L(\"col IN (?, ?, ?)\", \"a\", \"b\", \"c\")\r\n```\r\nPutting it together\r\n```go\r\nsql, _, _ := db.From(\"test\").Where(\r\n   goqu.I(\"col\").Eq(10),\r\n   goqu.L(`\"json\"::TEXT = \"other_json\"::TEXT`),\r\n).ToSql()\r\nfmt.Println(sql)\r\n```\r\n```sql\r\nSELECT * FROM \"test\" WHERE ((\"col\" = 10) AND \"json\"::TEXT = \"other_json\"::TEXT)\r\n```\r\nBoth the Identifier and Literal expressions will be ANDed together by default.\r\nYou may however want to have your expressions ORed together you can use the [`Or()`](https://godoc.org/github.com/doug-martin/goqu#example-Or) function to create an ExpressionList\r\n```go\r\nsql, _, _ := db.From(\"test\").Where(\r\n   goqu.Or(\r\n      goqu.I(\"col\").Eq(10),\r\n      goqu.L(`\"col\"::TEXT = \"other_col\"::TEXT`),\r\n   ),\r\n).ToSql()\r\nfmt.Println(sql)\r\n```  \r\n```sql\r\nSELECT * FROM \"test\" WHERE ((\"col\" = 10) OR \"col\"::TEXT = \"other_col\"::TEXT)\r\n```\r\n\r\n```go\r\nsql, _, _ := db.From(\"test\").Where(\r\n   Or(\r\n      goqu.I(\"col\").Eq(10),\r\n      goqu.L(`\"col\"::TEXT = \"other_col\"::TEXT`),\r\n   ),\r\n).ToSql()\r\nfmt.Println(sql)\r\n```\r\n```sql\r\nSELECT * FROM \"test\" WHERE ((\"col\" = 10) OR \"col\"::TEXT = \"other_col\"::TEXT)\r\n```\r\n\r\nYou can also use Or and the And function in tandem which will give you control not only over how the Expressions are joined together, but also how they are grouped\r\n```go\r\nsql, _, _ := db.From(\"test\").Where(\r\n   goqu.Or(\r\n      goqu.I(\"a\").Gt(10),\r\n      goqu.And(\r\n         goqu.I(\"b\").Eq(100),\r\n         goqu.I(\"c\").Neq(\"test\"),\r\n      ),\r\n   ),\r\n).ToSql()\r\nfmt.Println(sql)\r\n```\r\nOutput:\r\n```sql\r\nSELECT * FROM \"test\" WHERE ((\"a\" > 10) OR ((\"b\" = 100) AND (\"c\" != 'test')))\r\n```\r\n\r\nYou can also use Or with the map syntax\r\n```go\r\nsql, _, _ := db.From(\"test\").Where(\r\n\tgoqu.Or(\r\n        //Ex will be anded together\r\n\t\tgoqu.Ex{\r\n\t\t\t\"col1\": nil,\r\n\t\t\t\"col2\": true,\r\n\t\t},\r\n\t\tgoqu.Ex{\r\n\t\t\t\"col3\": nil,\r\n\t\t\t\"col4\": false,\r\n\t\t},\r\n\t\tgoqu.L(`\"col\"::TEXT = \"other_col\"::TEXT`),\r\n\t),\r\n).ToSql()\r\nfmt.Println(sql)\r\n```\r\nOutput:\r\n```sql\r\nSELECT * FROM \"test\" WHERE (((\"col1\" IS NULL) AND (\"col2\" IS TRUE)) OR ((\"col3\" IS NULL) AND (\"col4\" IS FALSE)) OR \"col\"::TEXT = \"other_col\"::TEXT)\r\n```\r\n<a name=\"complex-example\"></a>\r\n### Complex Example\r\n\r\nUsing the Ex map syntax\r\n```go\r\nsql, _, _ := db.From(\"test\").\r\n\tSelect(goqu.COUNT(\"*\")).\r\n\tInnerJoin(goqu.I(\"test2\"), goqu.On(goqu.I(\"test.fkey\").Eq(goqu.I(\"test2.id\")))).\r\n\tLeftJoin(goqu.I(\"test3\"), goqu.On(goqu.I(\"test2.fkey\").Eq(goqu.I(\"test3.id\")))).\r\n\tWhere(\r\n\tgoqu.Ex{\r\n\t\t\"test.name\":    goqu.Op{\"like\": regexp.MustCompile(\"^(a|b)\")},\r\n\t\t\"test2.amount\": goqu.Op{\"isNot\": nil},\r\n\t},\r\n\tgoqu.ExOr{\r\n\t\t\"test3.id\":     nil,\r\n\t\t\"test3.status\": []string{\"passed\", \"active\", \"registered\"},\r\n\t}).\r\n\tOrder(goqu.I(\"test.created\").Desc().NullsLast()).\r\n\tGroupBy(goqu.I(\"test.user_id\")).\r\n\tHaving(goqu.AVG(\"test3.age\").Gt(10)).\r\n\tToSql()\r\nfmt.Println(sql)\r\n```\r\n\r\nUsing the Expression syntax\r\n```go\r\nsql, _, _ := db.From(\"test\").\r\n    Select(goqu.COUNT(\"*\")).\r\n\tInnerJoin(goqu.I(\"test2\"), goqu.On(goqu.I(\"test.fkey\").Eq(goqu.I(\"test2.id\")))).\r\n\tLeftJoin(goqu.I(\"test3\"), goqu.On(goqu.I(\"test2.fkey\").Eq(goqu.I(\"test3.id\")))).\r\n\tWhere(\r\n\t    goqu.I(\"test.name\").Like(regexp.MustCompile(\"^(a|b)\")),\r\n\t    goqu.I(\"test2.amount\").IsNotNull(),\r\n\t    goqu.Or(\r\n\t\t    goqu.I(\"test3.id\").IsNull(),\r\n\t\t    goqu.I(\"test3.status\").In(\"passed\", \"active\", \"registered\"),\r\n\t)).\r\n\tOrder(goqu.I(\"test.created\").Desc().NullsLast()).\r\n\tGroupBy(goqu.I(\"test.user_id\")).\r\n\tHaving(goqu.AVG(\"test3.age\").Gt(10)).\r\n\tToSql()\r\nfmt.Println(sql)\r\n```\r\n\r\nBoth examples generate the following SQL\r\n\r\n```sql\r\nSELECT COUNT(*)\r\nFROM \"test\"\r\n  INNER JOIN \"test2\" ON (\"test\".\"fkey\" = \"test2\".\"id\")\r\n  LEFT JOIN \"test3\" ON (\"test2\".\"fkey\" = \"test3\".\"id\")\r\nWHERE (\r\n  (\"test\".\"name\" ~ '^(a|b)') AND\r\n  (\"test2\".\"amount\" IS NOT NULL) AND\r\n  (\r\n      (\"test3\".\"id\" IS NULL) OR\r\n      (\"test3\".\"status\" IN ('passed', 'active', 'registered'))\r\n  )\r\n)\r\nGROUP BY \"test\".\"user_id\"\r\nHAVING (AVG(\"test3\".\"age\") > 10)\r\nORDER BY \"test\".\"created\" DESC NULLS LAST\r\n```\r\n\r\n<a name=\"querying\"></a>\r\n## Querying\r\n\r\ngoqu also has basic query support through the use of either the Database or the Dataset.\r\n\r\n<a name=\"dataset\"></a>\r\n### Dataset\r\n\r\n* [`ScanStructs`](http://godoc.org/github.com/doug-martin/goqu#Dataset.ScanStructs) - scans rows into a slice of structs\r\n```go\r\nvar users []User\r\nif err := db.From(\"user\").ScanStructs(&users){\r\n    fmt.Println(err.Error())\r\n    return\r\n}\r\nfmt.Printf(\"\\n%+v\", users)\r\n```\r\n\r\n* [`ScanStruct`](http://godoc.org/github.com/doug-martin/goqu#Dataset.ScanStruct) - scans a row into a slice a struct, returns false if a row wasnt found\r\n```go\r\nvar user User\r\nfound, err := db.From(\"user\").ScanStruct(&user)\r\nif err != nil{\r\n    fmt.Println(err.Error())\r\n    return\r\n}\r\nif !found{\r\n    fmt.Println(\"No user found\")\r\n}else{\r\n    fmt.Printf(\"\\nFound user: %+v\", user)\r\n}\r\n```\r\n\r\n* [`ScanVals`](http://godoc.org/github.com/doug-martin/goqu#Dataset.ScanVals) - scans a rows of 1 column into a slice of primitive values\r\n```go\r\nvar ids []int64\r\nif err := db.From(\"user\").Select(\"id\").ScanVals(&ids){\r\n    fmt.Println(err.Error())\r\n    return\r\n}\r\nfmt.Printf(\"\\n%+v\", ids)\r\n```\r\n\r\n* [`ScanVal`](http://godoc.org/github.com/doug-martin/goqu#Dataset.ScanVal) - scans a row of 1 column into a primitive value, returns false if a row wasnt found. **Note** when using the dataset a `LIMIT` of 1 is automatically applied.\r\n```go\r\nvar id int64\r\nfound, err := db.From(\"user\").Select(\"id\").ScanVal(&id)\r\nif err != nil{\r\n    fmt.Println(err.Error())\r\n    return\r\n}\r\nif !found{\r\n    fmt.Println(\"No id found\")\r\n}else{\r\n    fmt.Printf(\"\\nFound id: %d\", id)\r\n}\r\n```\r\n\r\n* [`Count`](http://godoc.org/github.com/doug-martin/goqu#Dataset.Count) - Returns the count for the current query\r\n```go\r\ncount, err := db.From(\"user\").Count()\r\nif err != nil{\r\n    fmt.Println(err.Error())\r\n    return\r\n}\r\nfmt.Printf(\"\\nCount:= %d\", count)\r\n```\r\n\r\n* [`Pluck`](http://godoc.org/github.com/doug-martin/goqu#Dataset.Pluck) - Selects a single column and stores the results into a slice of primitive values\r\n```go\r\nvar ids []int64\r\nif err := db.From(\"user\").Pluck(&ids, \"id\"); err != nil{\r\n    fmt.Println(err.Error())\r\n    return\r\n}\r\nfmt.Printf(\"\\nIds := %+v\", ids)\r\n```\r\n\r\n* [`Insert`](http://godoc.org/github.com/doug-martin/goqu#Dataset.Insert) - Creates an `INSERT` statement and returns a [`CrudExec`](http://godoc.org/github.com/doug-martin/goqu#CrudExec) to execute the statement\r\n```go\r\ninsert := db.From(\"user\").Insert(goqu.Record{\"first_name\": \"Bob\", \"last_name\":\"Yukon\", \"created\": time.Now()})\r\nif _, err := insert.Exec(); err != nil{\r\n    fmt.Println(err.Error())\r\n    return\r\n}\r\n```\r\nInsert will also handle multi inserts if supported by the database\r\n```go\r\nusers := []goqu.Record{\r\n    {\"first_name\": \"Bob\", \"last_name\":\"Yukon\", \"created\": time.Now()},\r\n    {\"first_name\": \"Sally\", \"last_name\":\"Yukon\", \"created\": time.Now()},\r\n    {\"first_name\": \"Jimmy\", \"last_name\":\"Yukon\", \"created\": time.Now()},\r\n}\r\nif _, err := db.From(\"user\").Insert(users).Exec(); err != nil{\r\n    fmt.Println(err.Error())\r\n    return\r\n}\r\n```\r\nIf your database supports the `RETURN` clause you can also use the different Scan methods to get results\r\n```go\r\nvar ids []int64\r\nusers := []goqu.Record{\r\n    {\"first_name\": \"Bob\", \"last_name\":\"Yukon\", \"created\": time.Now()},\r\n    {\"first_name\": \"Sally\", \"last_name\":\"Yukon\", \"created\": time.Now()},\r\n    {\"first_name\": \"Jimmy\", \"last_name\":\"Yukon\", \"created\": time.Now()},\r\n}\r\nif err := db.From(\"user\").Returning(goqu.I(\"id\")).Insert(users).ScanVals(&ids); err != nil{\r\n    fmt.Println(err.Error())\r\n    return\r\n}\r\n```\r\n\r\n* [`Update`](http://godoc.org/github.com/doug-martin/goqu#Dataset.Update) - Creates an `UPDATE` statement and returns an[`CrudExec`](http://godoc.org/github.com/doug-martin/goqu#CrudExec) to execute the statement\r\n```go\r\nupdate := db.From(\"user\").\r\n    Where(goqu.I(\"status\").Eq(\"inactive\")).\r\n    Update(goqu.Record{\"password\": nil, \"updated\": time.Now()})\r\nif _, err := update.Exec(); err != nil{\r\n    fmt.Println(err.Error())\r\n    return\r\n}\r\n``````\r\nIf your database supports the `RETURN` clause you can also use the different Scan methods to get results\r\n```go\r\nvar ids []int64\r\nupdate := db.From(\"user\").\r\n    Where(goqu.Ex{\"status\":\"inactive\"}).\r\n    Returning(\"id\").\r\n    Update(goqu.Record{\"password\": nil, \"updated\": time.Now()})\r\nif err := update.ScanVals(&ids); err != nil{\r\n    fmt.Println(err.Error())\r\n    return\r\n}\r\n```\r\n* [`Delete`](http://godoc.org/github.com/doug-martin/goqu#Dataset.Delete) - Creates an `DELETE` statement and returns a [`CrudExec`](http://godoc.org/github.com/doug-martin/goqu#CrudExec) to execute the statement\r\n```go\r\ndelete := db.From(\"invoice\").\r\n    Where(goqu.Ex{\"status\":\"paid\"}).\r\n    Delete()\r\nif _, err := delete.Exec(); err != nil{\r\n    fmt.Println(err.Error())\r\n    return\r\n}\r\n```\r\nIf your database supports the `RETURN` clause you can also use the different Scan methods to get results\r\n```go\r\nvar ids []int64\r\ndelete := db.From(\"invoice\").\r\n    Where(goqu.I(\"status\").Eq(\"paid\")).\r\n    Returning(goqu.I(\"id\")).\r\n    Delete()\r\nif err := delete.ScanVals(&ids); err != nil{\r\n    fmt.Println(err.Error())\r\n    return\r\n}\r\n```\r\n\r\n<a name=\"dataset_prepared\"></a>\r\n#### Prepared Statements\r\n\r\nBy default the `Dataset` will interpolate all parameters, if you do not want to have values interolated you can use the [`Prepared`](http://godoc.org/github.com/doug-martin/goqu#Dataset.Prepared) method to prevent this.\r\n\r\n**Note** For the examples all placeholders are `?` this will be adapter specific when using other examples (e.g. Postgres `$1, $2...`)\r\n\r\n```go\r\n\r\npreparedDs := db.From(\"items\").Prepared(true)\r\n\r\nsql, args, _ := preparedDs.Where(goqu.Ex{\r\n\t\"col1\": \"a\",\r\n\t\"col2\": 1,\r\n\t\"col3\": true,\r\n\t\"col4\": false,\r\n\t\"col5\": []string{\"a\", \"b\", \"c\"},\r\n}).ToSql()\r\nfmt.Println(sql, args)\r\n\r\nsql, args, _ = preparedDs.ToInsertSql(\r\n\tgoqu.Record{\"name\": \"Test1\", \"address\": \"111 Test Addr\"},\r\n\tgoqu.Record{\"name\": \"Test2\", \"address\": \"112 Test Addr\"},\r\n)\r\nfmt.Println(sql, args)\r\n\r\nsql, args, _ = preparedDs.ToUpdateSql(\r\n\tgoqu.Record{\"name\": \"Test\", \"address\": \"111 Test Addr\"},\r\n)\r\nfmt.Println(sql, args)\r\n\r\nsql, args, _ = preparedDs.\r\n\tWhere(goqu.Ex{\"id\": goqu.Op{\"gt\": 10}}).\r\n\tToDeleteSql()\r\nfmt.Println(sql, args)\r\n\r\n// Output:\r\n// SELECT * FROM \"items\" WHERE ((\"col1\" = ?) AND (\"col2\" = ?) AND (\"col3\" IS TRUE) AND (\"col4\" IS FALSE) AND (\"col5\" IN (?, ?, ?))) [a 1 a b c]\r\n// INSERT INTO \"items\" (\"address\", \"name\") VALUES (?, ?), (?, ?) [111 Test Addr Test1 112 Test Addr Test2]\r\n// UPDATE \"items\" SET \"address\"=?,\"name\"=? [111 Test Addr Test]\r\n// DELETE FROM \"items\" WHERE (\"id\" > ?) [10]\r\n```\r\n\r\nWhen setting prepared to true executing the SQL using the different querying methods will also use the non-interpolated SQL also.\r\n\r\n```go\r\nvar items []Item\r\nsql, args, _ := db.From(\"items\").Prepared(true).Where(goqu.Ex{\r\n\t\"col1\": \"a\",\r\n\t\"col2\": 1,\r\n}).ScanStructs(&items)\r\n\r\n//Is the same as\r\ndb.ScanStructs(&items, `SELECT * FROM \"items\" WHERE ((\"col1\" = ?) AND (\"col2\" = ?))`,  \"a\", 1)\r\n```\r\n\r\n\r\n<a name=\"database\"></a>\r\n### Database\r\n\r\nThe Database also allows you to execute queries but expects raw SQL to execute. The supported methods are\r\n\r\n* [`Exec`](http://godoc.org/github.com/doug-martin/goqu#Database.Exec)\r\n* [`Prepare`](http://godoc.org/github.com/doug-martin/goqu#Database.Prepare)\r\n* [`Query`](http://godoc.org/github.com/doug-martin/goqu#Database.Query)\r\n* [`QueryRow`](http://godoc.org/github.com/doug-martin/goqu#Database.QueryRow)\r\n* [`ScanStructs`](http://godoc.org/github.com/doug-martin/goqu#Database.ScanStructs)\r\n* [`ScanStruct`](http://godoc.org/github.com/doug-martin/goqu#Database.ScanStruct)\r\n* [`ScanVals`](http://godoc.org/github.com/doug-martin/goqu#Database.ScanVals)\r\n* [`ScanVal`](http://godoc.org/github.com/doug-martin/goqu#Database.ScanVal)\r\n* [`Begin`](http://godoc.org/github.com/doug-martin/goqu#Database.Begin)\r\n\r\n<a name=\"transactions\"></a>\r\n### Transactions\r\n\r\n`goqu` has builtin support for transactions to make the use of the Datasets and querying seamless\r\n\r\n```go\r\ntx, err := db.Begin()\r\nif err != nil{\r\n   return err\r\n}\r\n//use tx.From to get a dataset that will execute within this transaction\r\nupdate := tx.From(\"user\").\r\n    Where(goqu.Ex(\"password\": nil}).\r\n    Update(goqu.Record{\"status\": \"inactive\"})\r\nif _, err = update.Exec(); err != nil{\r\n    if rErr := tx.Rollback(); rErr != nil{\r\n        return rErr\r\n    }\r\n    return err\r\n}\r\nif err = tx.Commit(); err != nil{\r\n    return err\r\n}\r\nreturn\r\n```\r\n\r\nThe [`TxDatabase`](http://godoc.org/github.com/doug-martin/goqu/#TxDatabase)  also has all methods that the [`Database`](http://godoc.org/github.com/doug-martin/goqu/#Database) has along with\r\n\r\n* [`Commit`](http://godoc.org/github.com/doug-martin/goqu#TxDatabase.Commit)\r\n* [`Rollback`](http://godoc.org/github.com/doug-martin/goqu#TxDatabase.Rollback)\r\n* [`Wrap`](http://godoc.org/github.com/doug-martin/goqu#TxDatabase.Wrap)\r\n\r\n#### Wrap\r\n\r\nThe [`TxDatabase.Wrap`](http://godoc.org/github.com/doug-martin/goqu/#TxDatabase.Wrap) is a convience method for automatically handling `COMMIT` and `ROLLBACK`\r\n\r\n```go\r\ntx, err := db.Begin()\r\nif err != nil{\r\n   return err\r\n}\r\nerr = tx.Wrap(func() error{\r\n  update := tx.From(\"user\").\r\n      Where(goqu.Ex(\"password\": nil}).\r\n      Update(goqu.Record{\"status\": \"inactive\"})\r\n  if _, err = update.Exec(); err != nil{\r\n      return err\r\n  }\r\n  return nil\r\n})\r\n//err will be the original error from the update statement, unless there was an error executing ROLLBACK\r\nif err != nil{\r\n    return err\r\n}\r\n```\r\n\r\n<a name=\"logging\"></a>\r\n## Logging\r\n\r\nTo enable trace logging of SQL statments use the [`Database.Logger`](http://godoc.org/github.com/doug-martin/goqu/#Database.Logger) method to set your logger.\r\n\r\n**NOTE** The logger must implement the [`Logger`](http://godoc.org/github.com/doug-martin/goqu/#Logger) interface\r\n\r\n**NOTE** If you start a transaction using a database your set a logger on the transaction will inherit that logger automatically\r\n\r\n\r\n<a name=\"adapters\"></a>\r\n## Adapters\r\n\r\nAdapters in goqu are the foundation of building the correct SQL for each DB dialect.\r\n\r\nBetween most dialects there is a large portion of shared syntax, for this reason we have a [`DefaultAdapter`](http://godoc.org/github.com/doug-martin/goqu/#DefaultAdapter) that can be used as a base for any new Dialect specific adapter.\r\nIn fact for most use cases you will not have to override any methods but instead just override the default values as documented for [`DefaultAdapter`](http://godoc.org/github.com/doug-martin/goqu/#DefaultAdapter).\r\n\r\n### Literal\r\n\r\nThe [`DefaultAdapter`](http://godoc.org/github.com/doug-martin/goqu/#DefaultAdapter) has a [`Literal`](http://godoc.org/github.com/doug-martin/goqu/#DefaultAdapter.Literal) function which should be used to serialize all sub expressions or values. This method prevents you from having to re-implement each adapter method while having your adapter methods called correctly.\r\n\r\n**How does it work?**\r\n\r\nThe Literal method delegates back to the [`Dataset.Literal`](http://godoc.org/github.com/doug-martin/goqu/#Dataset.Literal) method which then calls the appropriate method on the adapter acting as a trampoline, between the DefaultAdapter and your Adapter.\r\n\r\nFor example if your adapter overrode the [`DefaultAdapter.QuoteIdentifier`](http://godoc.org/github.com/doug-martin/goqu/#DefaultAdapter.QuoteIdentifier), method which is used by most methods in the [`DefaultAdapter`](http://godoc.org/github.com/doug-martin/goqu/#DefaultAdapter), we need to ensure that your Adapters QuoteIdentifier method is called instead of the default implementation.\r\n\r\nBecause the Dataset has a pointer to your Adapter it will call the correct method, so instead of calling `DefaultAdapter.QuoteIdentifier` internally we delegate back to the Dataset by calling the [`Dataset.Literal`](http://godoc.org/github.com/doug-martin/goqu/#Dataset.Literal) which will the call your Adapters method.\r\n\r\n```\r\nDataset.Literal -> Adapter.ExpressionListSql -> Adapter.Literal -> Dataset.Literal -> YourAdapter.QuoteIdentifier\r\n```\r\n\r\nIt is important to maintain this pattern when writing your own Adapter.\r\n\r\n### Registering\r\n\r\nWhen creating your adapters you must register your adapter with [`RegisterAdapter`](http://godoc.org/github.com/doug-martin/goqu/#RegisterAdapter). This method requires 2 arguments.\r\n\r\n1. dialect - The dialect for your adapter.\r\n2. datasetAdapterFactory - This is a factory function that will return a new goqu.Adapter  used to create the the dialect specific SQL.\r\n\r\n\r\nFor example the code for the postgres adapter is fairly short.\r\n```go\r\npackage postgres\r\n\r\nimport (\r\n    \"github.com/doug-martin/goqu\"\r\n)\r\n\r\n//postgres requires a $ placeholder for prepared statements\r\nconst placeholder_rune = '$'\r\n\r\nfunc newDatasetAdapter(ds *goqu.Dataset) goqu.Adapter {\r\n    ret := goqu.NewDefaultAdapter(ds).(*goqu.DefaultAdapter)\r\n\r\n    //override the settings required\r\n    ret.PlaceHolderRune = placeholder_rune\r\n    //postgres requires a paceholder number (e.g. $1)\r\n    ret.IncludePlaceholderNum = true\r\n    return ret\r\n}\r\n\r\nfunc init() {\r\n    //register our adapter with goqu\r\n    goqu.RegisterAdapter(\"postgres\", newDatasetAdapter)\r\n}\r\n```\r\n\r\nIf you are looking to write your own adapter take a look at the postgresm, mysql or sqlite3 adapter located at <https://github.com/doug-martin/goqu/tree/master/adapters>.\r\n\r\n<a name=\"contributions\"></a>\r\n## Contributions\r\n\r\nI am always welcoming contributions of any type. Please open an issue or create a PR if you find an issue with any of the following.\r\n\r\n* An issue with Documentation\r\n* You found the documentation lacking in some way\r\n\r\nIf you have an issue with the package please include the following\r\n\r\n* The dialect you are using\r\n* A description of the problem\r\n* A short example of how to reproduce (if applicable)\r\n\r\nWithout those basics it can be difficult to reproduce your issue locally. You may be asked for more information but that is a good starting point.\r\n\r\n### New Features\r\n\r\nNew features and/or enhancements are great and I encourage you to either submit a PR or create an issue. In both cases include the following as the need/requirement may not be readily apparent.\r\n\r\n1. The use case\r\n2. A short example\r\n\r\nIf you are issuing a PR also also include the following\r\n\r\n1. Tests - otherwise the PR will not be merged\r\n2. Documentation - otherwise the PR will not be merged\r\n3. Examples - [If applicable] see example_test.go for examples\r\n\r\nIf you find an issue you want to work on please comment on it letting other people know you are looking at it and I will assign the issue to you.\r\n\r\nIf want to work on an issue but dont know where to start just leave a comment and I'll be more than happy to point you in the right direction.\r\n\r\n## License\r\n\r\n`goqu` is released under the [MIT License](http://www.opensource.org/licenses/MIT).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}